import Foundation

struct BlockMetadata: Decodable {
	let name: String
	let description: String?
	let metadata: [String: String]?
	let readme: String?

	let propDefinitions: [PropDefinition]
	let js: String
	let css: [String]
	let assets: [String]

	// Sync with build.ts in BlockParty
	var subdirectory: String {
		let blockId = metadata?["id"] ?? name
		return blockId.replacing(/[^a-zA-Z0-9-_]/, with: "-")
	}
}

struct PropDefinition: Decodable {
	let name: String
	let type: String
	let optional: Bool
	let properties: [PropDefinition]?
	let description: String?
}

struct BuildOutput: Decodable {
	let blocks: [BlockMetadata]
	let importmap: [String: String]
}

/// Main entry point for the BlockParty build tool
@main
struct BlockPartyTool {
	static func main() async {
		let arguments = CommandLine.arguments

		guard arguments.count >= 3 else {
			print("Usage: BlockPartyTool-tool <package-dir> <output-dir>")
			exit(1)
		}

		let packageDir = arguments[1]
		let outputDir = arguments[2]

		do {
			try await buildBlocks(packageDir: packageDir, outputDir: outputDir)
		} catch let buildError as BuildError {
			print("âŒ Build failed: \(buildError)")
			switch buildError {
			case .processFailure:
				print(
					"ðŸ’¡ Make sure your project has an NPM package.json file with 'blockparty' as a devDependency and that you've run 'npm install'."
				)
			}
			exit(1)
		} catch {
			print("âŒ Build failed: \(error)")
			exit(1)
		}
	}

	static func buildBlocks(packageDir: String, outputDir: String) async throws
	{
		let packageURL = URL(fileURLWithPath: packageDir)
		let outputURL = URL(fileURLWithPath: outputDir)

		// Run npx blockparty command
		let process = Process()
		process.executableURL = URL(fileURLWithPath: "/usr/bin/env")
		let args = [
			"npx", "--no", "--offline", "blockparty", "build", "--individually",
			packageDir,
			outputDir,
		]
		process.arguments = args
		process.currentDirectoryURL = packageURL

		let outputPipe = Pipe()
		let errorPipe = Pipe()
		process.standardOutput = outputPipe
		process.standardError = errorPipe

		print("ðŸš€ Running: \(args.joined(separator: " "))")

		try process.run()

		// Read output
		let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
		if let output = String(data: outputData, encoding: .utf8),
			!output.isEmpty
		{
			print(output)
		}

		// Read errors
		let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()
		if let errorOutput = String(data: errorData, encoding: .utf8),
			!errorOutput.isEmpty
		{
			print(errorOutput)
		}

		process.waitUntilExit()

		guard process.terminationStatus == 0 else {
			throw BuildError.processFailure(exitCode: process.terminationStatus)
		}

		print("\nðŸ“‹ Reading build output from index.json...")
		let indexPath = outputURL.appending(path: "index.json")
		let indexData = try Data(contentsOf: indexPath)
		let buildOutput = try JSONDecoder().decode(
			BuildOutput.self,
			from: indexData
		)

		print(
			"âœ¨ Generating Swift code for \(buildOutput.blocks.count) block(s)..."
		)
		let generatedCode = generateSwiftCode(
			for: buildOutput,
			outputDir: outputDir
		)

		let generatedFilePath = outputURL.appending(
			path: "BlockParty-Generated.swift"
		)
		try generatedCode.write(
			to: generatedFilePath,
			atomically: true,
			encoding: .utf8
		)

		print("âœ… Generated BlockParty-Generated.swift")
	}

	static func generateSwiftCode(
		for buildOutput: BuildOutput,
		outputDir: String
	) -> String {
		var code = """
			// This file is auto-generated by BlockPartyTool. Do not edit manually.
			import Foundation
			import BlockParty


			"""

		for block in buildOutput.blocks {
			code += generateBlockStruct(
				for: block,
				importMap: buildOutput.importmap,
				outputDir: outputDir
			)
			code += "\n\n"
		}

		return code
	}

	static func generateBlockStruct(
		for block: BlockMetadata,
		importMap: [String: String],
		outputDir: String
	) -> String {
		let structName = swiftIdentifier(for: block.name)

		var code = ""

		// Add documentation if available
		if let description = block.description {
			code += "/// \(description)\n"
		}

		var isEncodable = true
		var hasEncodableMembers = false
		var mappedProps: [(prop: PropDefinition, mapped: MappedType)] = []
		for prop in block.propDefinitions {
			let mapped = mapTypeScriptTypeToSwift(
				prop.type,
				isOptional: prop.optional
			)
			isEncodable = isEncodable && mapped.isEncodable
			hasEncodableMembers = hasEncodableMembers || mapped.isEncodable
			mappedProps.append((prop: prop, mapped: mapped))
		}

		code +=
			"public struct \(structName): Block\(isEncodable ? ", Encodable" : "") {\n"

		// Generate properties from propDefinitions
		for (prop, mapped) in mappedProps {
			if let description = prop.description {
				code += "\t/// \(description)\n"
			}
			code +=
				"\tpublic let \(swiftIdentifier(for: prop.name)): \(mapped.swiftType)\n"
		}

		// Add static blockType property
		code += "\n"
		code += "\tpublic static var blockType: BlockType {\n"
		code += "\t\tBlockType(\n"
		code += "\t\t\tjs: \"\(block.js)\",\n"
		if !block.css.isEmpty {
			code +=
				"\t\t\tcss: [\(block.css.map { "\"\($0)\"" }.joined(separator: ", "))],\n"
		} else {
			code += "\t\t\tcss: [],\n"
		}

		// Add import map
		code += "\t\t\timportMap: [\n"
		for (key, value) in importMap.sorted(by: { $0.key < $1.key }) {
			code += "\t\t\t\t\"\(key)\": \"\(value)\",\n"
		}
		code += "\t\t\t]) { baseURL in\n"

		// Add precache closure
		code += "\t\t\t\t[\n"

		// Precache the JS file
		let jsFileName = URL(fileURLWithPath: block.js).lastPathComponent
		let jsFileNameWithoutExt = jsFileName.replacingOccurrences(
			of: ".js",
			with: ""
		)
		code += "\t\t\t\t\tBundleCache.cachedResponse(\n"
		code += "\t\t\t\t\t\tbaseURL: baseURL,\n"
		code += "\t\t\t\t\t\tforResource: \"\(jsFileNameWithoutExt)\",\n"
		code += "\t\t\t\t\t\twithExtension: \"js\",\n"
		code += "\t\t\t\t\t\tsubdirectory: \"\(block.subdirectory)\",\n"
		code += "\t\t\t\t\t\tcontentType: \"application/javascript\",\n"
		code += "\t\t\t\t\t\tin: .module\n"
		code += "\t\t\t\t\t),\n"

		// Precache CSS files
		for cssPath in block.css {
			let cssFileName = URL(fileURLWithPath: cssPath).lastPathComponent
			let cssFileNameWithoutExt = cssFileName.replacingOccurrences(
				of: ".css",
				with: ""
			)
			code += "\t\t\t\t\tBundleCache.cachedResponse(\n"
			code += "\t\t\t\t\t\tbaseURL: baseURL,\n"
			code += "\t\t\t\t\t\tforResource: \"\(cssFileNameWithoutExt)\",\n"
			code += "\t\t\t\t\t\twithExtension: \"css\",\n"
			code += "\t\t\t\t\t\tsubdirectory: \"\(block.subdirectory)\",\n"
			code += "\t\t\t\t\t\tcontentType: \"text/css\",\n"
			code += "\t\t\t\t\t\tin: .module\n"
			code += "\t\t\t\t\t),\n"
		}

		code += "\t\t\t\t].compactMap { $0 }\n"
		code += "\t\t\t}\n"
		code += "\t}\n"

		// Add initializer
		code += "\n"
		code += "\tpublic init(\n"
		for (index, prop) in block.propDefinitions.enumerated() {
			let mapped = mapTypeScriptTypeToSwift(
				prop.type,
				isOptional: prop.optional
			)
			let comma = index < block.propDefinitions.count - 1 ? "," : ""
			code +=
				"\t\t\(swiftIdentifier(for: prop.name)): \(mapped.swiftType)\(comma)\n"
		}
		code += "\t) {\n"
		for prop in block.propDefinitions {
			let propName = swiftIdentifier(for: prop.name)
			code += "\t\tself.\(propName) = \(propName)\n"
		}
		code += "\t}\n"

		// Add custom jsValue implementation for non-Encodable blocks
		if !isEncodable {
			code += "\n"
			code +=
				"\tpublic func jsValue(context: JSEncodingContext) throws -> Data {\n"
			if hasEncodableMembers {
				code += "\t\tlet encoder = JSONEncoder()\n"
			}
			code += "\t\tvar jsonString = \"{\"\n"
			for (index, (prop, mapped)) in mappedProps.enumerated() {
				let propName = swiftIdentifier(for: prop.name)
				let isFunction = mapped.swiftType.contains("->")

				if index > 0 {
					code += "\t\tjsonString += \",\"\n"
				}
				code += "\t\tjsonString += \"\\\"\(prop.name)\\\":\"\n"

				if isFunction {
					// Register function callback
					if mapped.isOptional {
						code += "\t\tif let \(propName)Fn = \(propName) {\n"
						code +=
							"\t\t\tjsonString += context.registerSyncCallback { args in\n"
						code += "\t\t\t\t\(propName)Fn()\n"
						code += "\t\t\t\treturn nil\n"
						code += "\t\t\t}\n"
						code += "\t\t} else {\n"
						code += "\t\t\tjsonString += \"undefined\"\n"
						code += "\t\t}\n"
					} else {
						code +=
							"\t\tjsonString += context.registerSyncCallback { args in\n"
						code += "\t\t\t\(propName)()\n"
						code += "\t\t\treturn nil\n"
						code += "\t\t}\n"
					}
				} else {
					// Regular encodable property
					code +=
						"\t\tjsonString += try BlockParty.dataToUTF8String(encoder.encode(\(propName)))\n"
				}
			}
			code += "\t\tjsonString += \"}\"\n"
			code += "\t\treturn Data(jsonString.utf8)\n"
			code += "\t}\n"
		}

		code += "}"

		return code
	}

	struct MappedType {
		let swiftType: String
		let isEncodable: Bool
		let isOptional: Bool
		let isFunction: Bool
	}

	static func mapTypeScriptTypeToSwift<S: StringProtocol>(
		_ tsType: S,
		isOptional: Bool
	)
		-> MappedType
	{
		var isEncodable = true
		var isFunction = false
		var mappedType: String
		let cleanType = tsType.trimmingCharacters(in: .whitespaces)

		// Handle parts wrapped in parentheses first
		if cleanType.hasPrefix("(") && cleanType.hasSuffix(")") {
			let mapped = mapTypeScriptTypeToSwift(
				cleanType.dropFirst().dropLast(),
				isOptional: false
			)
			isEncodable = isEncodable && mapped.isEncodable
			mappedType = "(\(mapped.swiftType))"
		} else {
			switch cleanType {
			case "string":
				mappedType = "String"
			case "number":
				mappedType = "Double"
			case "boolean":
				mappedType = "Bool"
			case "any":
				mappedType = "Any"
			case "void", "undefined", "null":
				mappedType = "Void"
			default:
				if cleanType.contains("|") && cleanType.contains("undefined") {
					// Handle union types with undefined (e.g., "string | undefined")
					let parts = cleanType.split(separator: "|").map {
						$0.trimmingCharacters(in: .whitespaces)
					}
					if let nonUndefinedType = parts.first(where: {
						$0 != "undefined"
					}) {
						return mapTypeScriptTypeToSwift(
							nonUndefinedType,
							isOptional: true
						)
					}
				}
				if cleanType.contains("=>") {
					// Handle function types (e.g., "() => void")
					isEncodable = false
					isFunction = true
					mappedType = cleanType.split(separator: "=>").map({
						mapTypeScriptTypeToSwift($0, isOptional: false)
							.swiftType
					}).joined(separator: " -> ")
				} else {
					mappedType = String(cleanType)
				}
			}
		}

		if isOptional {
			mappedType += "?"
		}

		return MappedType(
			swiftType: mappedType,
			isEncodable: isEncodable,
			isOptional: isOptional,
			isFunction: isFunction
		)
	}

	static func swiftIdentifier(for name: String) -> String {
		// Replace hyphens with underscores and handle Swift keywords
		let sanitized = name.replacingOccurrences(of: "-", with: "_")

		// Check if it's a Swift keyword and escape it
		let swiftKeywords = [
			"associatedtype", "class", "deinit", "enum", "extension",
			"fileprivate",
			"func", "import", "init", "inout", "internal", "let", "open",
			"operator",
			"private", "precedencegroup", "protocol", "public", "rethrows",
			"static",
			"struct", "subscript", "typealias", "var", "break", "case", "catch",
			"continue", "default", "defer", "do", "else", "fallthrough", "for",
			"guard",
			"if", "in", "repeat", "return", "throw", "switch", "where", "while",
			"as",
			"false", "is", "nil", "self", "Self", "super", "throws", "true",
			"try",
		]

		if swiftKeywords.contains(sanitized) {
			return "`\(sanitized)`"
		}

		return sanitized
	}
}

enum BuildError: Error, CustomStringConvertible {
	case processFailure(exitCode: Int32)

	var description: String {
		switch self {
		case .processFailure(let exitCode):
			return "npx blockparty process failed with exit code \(exitCode)"
		}
	}
}
