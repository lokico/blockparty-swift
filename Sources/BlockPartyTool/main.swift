import Foundation

struct BlockMetadata: Decodable {
	let name: String
	let description: String?
	let metadata: [String: String]?
	let readme: String?

	let propDefinitions: [PropDefinition]
	let js: String
	let css: [String]
	let assets: [String]

	// Sync with build.ts in BlockParty
	var subdirectory: String {
		let blockId = metadata?["id"] ?? name
		return blockId.replacing(/[^a-zA-Z0-9-_]/, with: "-")
	}
}

struct PropDefinition: Decodable {
	let name: String
	let type: String
	let optional: Bool
	let properties: [PropDefinition]?
	let description: String?
}

struct BuildOutput: Decodable {
	let blocks: [BlockMetadata]
	let importmap: [String: String]
}

/// Main entry point for the BlockParty build tool
@main
struct BlockPartyTool {
	static func main() async {
		let arguments = CommandLine.arguments

		guard arguments.count >= 3 else {
			print("Usage: BlockPartyTool-tool <package-dir> <output-dir>")
			exit(1)
		}

		let packageDir = arguments[1]
		let outputDir = arguments[2]

		do {
			try await buildBlocks(packageDir: packageDir, outputDir: outputDir)
		} catch let buildError as BuildError {
			print("âŒ Build failed: \(buildError)")
			switch buildError {
			case .processFailure:
				print(
					"ðŸ’¡ Make sure your project has an NPM package.json file with 'blockparty' as a devDependency and that you've run 'npm install'."
				)
			}
			exit(1)
		} catch {
			print("âŒ Build failed: \(error)")
			exit(1)
		}
	}

	static func buildBlocks(packageDir: String, outputDir: String) async throws
	{
		let packageURL = URL(fileURLWithPath: packageDir)
		let outputURL = URL(fileURLWithPath: outputDir)

		// Run npx blockparty command
		let process = Process()
		process.executableURL = URL(fileURLWithPath: "/usr/bin/env")
		let args = [
			"npx", "--no", "--offline", "blockparty", "build", "--individually",
			packageDir,
			outputDir,
		]
		process.arguments = args
		process.currentDirectoryURL = packageURL

		let outputPipe = Pipe()
		let errorPipe = Pipe()
		process.standardOutput = outputPipe
		process.standardError = errorPipe

		print("ðŸš€ Running: \(args.joined(separator: " "))")

		try process.run()

		// Read output
		let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
		if let output = String(data: outputData, encoding: .utf8),
			!output.isEmpty
		{
			print(output)
		}

		// Read errors
		let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()
		if let errorOutput = String(data: errorData, encoding: .utf8),
			!errorOutput.isEmpty
		{
			print(errorOutput)
		}

		process.waitUntilExit()

		guard process.terminationStatus == 0 else {
			throw BuildError.processFailure(exitCode: process.terminationStatus)
		}

		print("\nðŸ“‹ Reading build output from index.json...")
		let indexPath = outputURL.appending(path: "index.json")
		let indexData = try Data(contentsOf: indexPath)
		let buildOutput = try JSONDecoder().decode(
			BuildOutput.self,
			from: indexData
		)

		print(
			"âœ¨ Generating Swift code for \(buildOutput.blocks.count) block(s)..."
		)
		let generatedCode = generateSwiftCode(
			for: buildOutput,
			outputDir: outputDir
		)

		let generatedFilePath = outputURL.appending(
			path: "BlockParty-Generated.swift"
		)
		try generatedCode.write(
			to: generatedFilePath,
			atomically: true,
			encoding: .utf8
		)

		print("âœ… Generated BlockParty-Generated.swift")
	}

	static func generateSwiftCode(
		for buildOutput: BuildOutput,
		outputDir: String
	) -> String {
		var code = """
			// This file is auto-generated by BlockPartyTool. Do not edit manually.
			import Foundation
			import BlockParty


			"""

		for block in buildOutput.blocks {
			code += generateBlockStruct(
				for: block,
				importMap: buildOutput.importmap,
				outputDir: outputDir
			)
			code += "\n\n"
		}

		return code
	}

	static func generateBlockStruct(
		for block: BlockMetadata,
		importMap: [String: String],
		outputDir: String
	) -> String {
		let structName = swiftIdentifier(for: block.name)

		var code = ""

		// Add documentation if available
		if let description = block.description {
			code += "/// \(description)\n"
		}

		code += "public struct \(structName): Block, Encodable {\n"

		// Generate properties from propDefinitions
		for prop in block.propDefinitions {
			if let description = prop.description {
				code += "\t/// \(description)\n"
			}

			let swiftType = mapTypeScriptTypeToSwift(
				prop.type,
				isOptional: prop.optional
			)
			let optionalMark = prop.optional ? "?" : ""
			code +=
				"\tpublic let \(swiftIdentifier(for: prop.name)): \(swiftType)\(optionalMark)\n"
		}

		// Add static blockType property
		code += "\n"
		code += "\tpublic static var blockType: BlockType {\n"
		code += "\t\tBlockType(\n"
		code += "\t\t\tjs: \"\(block.js)\",\n"
		if !block.css.isEmpty {
			code +=
				"\t\t\tcss: [\(block.css.map { "\"\($0)\"" }.joined(separator: ", "))],\n"
		} else {
			code += "\t\t\tcss: [],\n"
		}

		// Add import map
		code += "\t\t\timportMap: [\n"
		for (key, value) in importMap.sorted(by: { $0.key < $1.key }) {
			code += "\t\t\t\t\"\(key)\": \"\(value)\",\n"
		}
		code += "\t\t\t]) { baseURL in\n"

		// Add precache closure
		code += "\t\t\t\t[\n"

		// Precache the JS file
		let jsFileName = URL(fileURLWithPath: block.js).lastPathComponent
		let jsFileNameWithoutExt = jsFileName.replacingOccurrences(
			of: ".js",
			with: ""
		)
		code += "\t\t\t\t\tBundleCache.cachedResponse(\n"
		code += "\t\t\t\t\t\tbaseURL: baseURL,\n"
		code += "\t\t\t\t\t\tforResource: \"\(jsFileNameWithoutExt)\",\n"
		code += "\t\t\t\t\t\twithExtension: \"js\",\n"
		code += "\t\t\t\t\t\tsubdirectory: \"\(block.subdirectory)\",\n"
		code += "\t\t\t\t\t\tcontentType: \"application/javascript\",\n"
		code += "\t\t\t\t\t\tin: .module\n"
		code += "\t\t\t\t\t),\n"

		// Precache CSS files
		for cssPath in block.css {
			let cssFileName = URL(fileURLWithPath: cssPath).lastPathComponent
			let cssFileNameWithoutExt = cssFileName.replacingOccurrences(
				of: ".css",
				with: ""
			)
			code += "\t\t\t\t\tBundleCache.cachedResponse(\n"
			code += "\t\t\t\t\t\tbaseURL: baseURL,\n"
			code += "\t\t\t\t\t\tforResource: \"\(cssFileNameWithoutExt)\",\n"
			code += "\t\t\t\t\t\twithExtension: \"css\",\n"
			code += "\t\t\t\t\t\tsubdirectory: \"\(block.subdirectory)\",\n"
			code += "\t\t\t\t\t\tcontentType: \"text/css\",\n"
			code += "\t\t\t\t\t\tin: .module\n"
			code += "\t\t\t\t\t),\n"
		}

		code += "\t\t\t\t].compactMap { $0 }\n"
		code += "\t\t\t}\n"
		code += "\t}\n"

		// Add initializer
		code += "\n"
		code += "\tpublic init(\n"
		for (index, prop) in block.propDefinitions.enumerated() {
			let swiftType = mapTypeScriptTypeToSwift(
				prop.type,
				isOptional: prop.optional
			)
			let optionalMark = prop.optional ? "?" : ""
			let comma = index < block.propDefinitions.count - 1 ? "," : ""
			code +=
				"\t\t\(swiftIdentifier(for: prop.name)): \(swiftType)\(optionalMark)\(comma)\n"
		}
		code += "\t) {\n"
		for prop in block.propDefinitions {
			let propName = swiftIdentifier(for: prop.name)
			code += "\t\tself.\(propName) = \(propName)\n"
		}
		code += "\t}\n"

		code += "}"

		return code
	}

	static func mapTypeScriptTypeToSwift(_ tsType: String, isOptional: Bool)
		-> String
	{
		// Handle common TypeScript types
		let cleanType = tsType.trimmingCharacters(in: .whitespaces)

		// Handle union types with undefined (e.g., "string | undefined")
		if cleanType.contains("|") && cleanType.contains("undefined") {
			let parts = cleanType.split(separator: "|").map {
				$0.trimmingCharacters(in: .whitespaces)
			}
			if let nonUndefinedType = parts.first(where: { $0 != "undefined" })
			{
				return mapTypeScriptTypeToSwift(
					nonUndefinedType,
					isOptional: true
				)
			}
		}

		// Handle function types (e.g., "() => void")
		if cleanType.contains("=>") {
			return "String"  // Encode functions as strings (not callable from Swift)
		}

		// Map basic types
		switch cleanType {
		case "string":
			return "String"
		case "number":
			return "Double"
		case "boolean":
			return "Bool"
		case "any":
			return "AnyCodable"
		case "void", "undefined", "null":
			return "String"
		default:
			// For complex types or unknown types, use String
			return "String"
		}
	}

	static func swiftIdentifier(for name: String) -> String {
		// Replace hyphens with underscores and handle Swift keywords
		let sanitized = name.replacingOccurrences(of: "-", with: "_")

		// Check if it's a Swift keyword and escape it
		let swiftKeywords = [
			"associatedtype", "class", "deinit", "enum", "extension",
			"fileprivate",
			"func", "import", "init", "inout", "internal", "let", "open",
			"operator",
			"private", "precedencegroup", "protocol", "public", "rethrows",
			"static",
			"struct", "subscript", "typealias", "var", "break", "case", "catch",
			"continue", "default", "defer", "do", "else", "fallthrough", "for",
			"guard",
			"if", "in", "repeat", "return", "throw", "switch", "where", "while",
			"as",
			"false", "is", "nil", "self", "Self", "super", "throws", "true",
			"try",
		]

		if swiftKeywords.contains(sanitized) {
			return "`\(sanitized)`"
		}

		return sanitized
	}
}

enum BuildError: Error, CustomStringConvertible {
	case processFailure(exitCode: Int32)

	var description: String {
		switch self {
		case .processFailure(let exitCode):
			return "npx blockparty process failed with exit code \(exitCode)"
		}
	}
}
