import Foundation

struct BlockMetadata: Decodable {
	let name: String
	let description: String?
	let metadata: [String: String]?
	let readme: String?

	let propDefinitions: [PropDefinition]
	let js: String
	let css: [String]
	let assets: [String]

	// Sync with build.ts in BlockParty
	var subdirectory: String {
		let blockId = metadata?["id"] ?? name
		return blockId.replacing(/[^a-zA-Z0-9-_]/, with: "-")
	}
}

struct PropDefinition: Decodable {
	let name: String
	let type: String
	let optional: Bool
	let properties: [PropDefinition]?
	let parameters: [PropDefinition]?
	let description: String?
}

struct BuildOutput: Decodable {
	let blocks: [BlockMetadata]
	let importmap: [String: String]
}

/// Main entry point for the BlockParty build tool
@main
struct BlockPartyTool {
	static func main() async {
		let arguments = CommandLine.arguments

		guard arguments.count >= 3 else {
			print("Usage: BlockPartyTool-tool <package-dir> <output-dir>")
			exit(1)
		}

		let packageDir = arguments[1]
		let outputDir = arguments[2]

		do {
			try await buildBlocks(packageDir: packageDir, outputDir: outputDir)
		} catch let buildError as BuildError {
			print("âŒ Build failed: \(buildError)")
			switch buildError {
			case .processFailure:
				print(
					"ðŸ’¡ Make sure your project has an NPM package.json file with 'blockparty' as a devDependency and that you've run 'npm install'."
				)
			}
			exit(1)
		} catch {
			print("âŒ Build failed: \(error)")
			exit(1)
		}
	}

	static func buildBlocks(packageDir: String, outputDir: String) async throws
	{
		let packageURL = URL(fileURLWithPath: packageDir)
		let outputURL = URL(fileURLWithPath: outputDir)

		// Run npx blockparty command
		let process = Process()
		process.executableURL = URL(fileURLWithPath: "/usr/bin/env")
		let args = [
			"npx", "--no", "--offline", "blockparty", "build", "--individually",
			packageDir,
			outputDir,
		]
		process.arguments = args
		process.currentDirectoryURL = packageURL

		let outputPipe = Pipe()
		let errorPipe = Pipe()
		process.standardOutput = outputPipe
		process.standardError = errorPipe

		print("ðŸš€ Running: \(args.joined(separator: " "))")

		try process.run()

		// Read output
		let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
		if let output = String(data: outputData, encoding: .utf8),
			!output.isEmpty
		{
			print(output)
		}

		// Read errors
		let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()
		if let errorOutput = String(data: errorData, encoding: .utf8),
			!errorOutput.isEmpty
		{
			print(errorOutput)
		}

		process.waitUntilExit()

		guard process.terminationStatus == 0 else {
			throw BuildError.processFailure(exitCode: process.terminationStatus)
		}

		print("\nðŸ“‹ Reading build output from index.json...")
		let indexPath = outputURL.appending(path: "index.json")
		let indexData = try Data(contentsOf: indexPath)
		let buildOutput = try JSONDecoder().decode(
			BuildOutput.self,
			from: indexData
		)

		print(
			"âœ¨ Generating Swift code for \(buildOutput.blocks.count) block(s)..."
		)
		let generatedCode = generateSwiftCode(
			for: buildOutput,
			outputDir: outputDir
		)

		let generatedFilePath = outputURL.appending(
			path: "BlockParty-Generated.swift"
		)
		try generatedCode.write(
			to: generatedFilePath,
			atomically: true,
			encoding: .utf8
		)

		print("âœ… Generated BlockParty-Generated.swift")
	}

	static func generateSwiftCode(
		for buildOutput: BuildOutput,
		outputDir: String
	) -> String {
		var code = """
			// This file is auto-generated by BlockPartyTool. Do not edit manually.
			import Foundation
			import BlockParty


			"""

		for block in buildOutput.blocks {
			code += generateBlockStruct(
				for: block,
				importMap: buildOutput.importmap,
				outputDir: outputDir
			)
			code += "\n\n"
		}

		return code
	}

	static func generateBlockStruct(
		for block: BlockMetadata,
		importMap: [String: String],
		outputDir: String
	) -> String {
		let structName = swiftIdentifier(for: block.name)

		let structInfo = generateStruct(
			name: structName,
			description: block.description,
			baseConformance: "Block",
			properties: block.propDefinitions,
			indent: ""
		)

		var code = structInfo.openingCode

		// Add static blockType property
		code += "\n"
		code += "\tpublic static var blockType: BlockType {\n"
		code += "\t\tBlockType(\n"
		code += "\t\t\tjs: \"\(block.js)\",\n"
		if !block.css.isEmpty {
			code +=
				"\t\t\tcss: [\(block.css.map { "\"\($0)\"" }.joined(separator: ", "))],\n"
		} else {
			code += "\t\t\tcss: [],\n"
		}

		// Add import map
		code += "\t\t\timportMap: [\n"
		for (key, value) in importMap.sorted(by: { $0.key < $1.key }) {
			code += "\t\t\t\t\"\(key)\": \"\(value)\",\n"
		}
		code += "\t\t\t]) { baseURL in\n"

		// Add precache closure
		code += "\t\t\t\t[\n"

		// Precache the JS file
		let jsFileName = URL(fileURLWithPath: block.js).lastPathComponent
		let jsFileNameWithoutExt = jsFileName.replacingOccurrences(
			of: ".js",
			with: ""
		)
		code += "\t\t\t\t\tBundleCache.cachedResponse(\n"
		code += "\t\t\t\t\t\tbaseURL: baseURL,\n"
		code += "\t\t\t\t\t\tforResource: \"\(jsFileNameWithoutExt)\",\n"
		code += "\t\t\t\t\t\twithExtension: \"js\",\n"
		code += "\t\t\t\t\t\tsubdirectory: \"\(block.subdirectory)\",\n"
		code += "\t\t\t\t\t\tcontentType: \"application/javascript\",\n"
		code += "\t\t\t\t\t\tin: .module\n"
		code += "\t\t\t\t\t),\n"

		// Precache CSS files
		for cssPath in block.css {
			let cssFileName = URL(fileURLWithPath: cssPath).lastPathComponent
			let cssFileNameWithoutExt = cssFileName.replacingOccurrences(
				of: ".css",
				with: ""
			)
			code += "\t\t\t\t\tBundleCache.cachedResponse(\n"
			code += "\t\t\t\t\t\tbaseURL: baseURL,\n"
			code += "\t\t\t\t\t\tforResource: \"\(cssFileNameWithoutExt)\",\n"
			code += "\t\t\t\t\t\twithExtension: \"css\",\n"
			code += "\t\t\t\t\t\tsubdirectory: \"\(block.subdirectory)\",\n"
			code += "\t\t\t\t\t\tcontentType: \"text/css\",\n"
			code += "\t\t\t\t\t\tin: .module\n"
			code += "\t\t\t\t\t),\n"
		}

		code += "\t\t\t\t].compactMap { $0 }\n"
		code += "\t\t\t}\n"
		code += "\t}\n"

		code += "}"

		return code
	}

	struct MappedType {
		let swiftType: String
		let isEncodable: Bool
		let isOptional: Bool
		let isFunction: Bool
		let isNestedObject: Bool
	}

	struct StructInfo {
		let name: String
		let openingCode: String
		let isEncodable: Bool
	}

	// Helper function to process properties with nested struct generation
	static func processProperties(
		properties: [PropDefinition],
		indent: String
	) -> (
		mappedProps: [(prop: PropDefinition, mapped: MappedType)],
		nestedStructInfos: [StructInfo],
		isEncodable: Bool
	) {
		var mappedProps: [(prop: PropDefinition, mapped: MappedType)] = []
		var nestedStructInfos: [StructInfo] = []
		var isEncodable = true

		// First pass: recursively generate nested structs for properties with nested properties
		for prop in properties {
			if let nestedProps = prop.properties {
				let nestedStructName =
					swiftIdentifier(for: prop.name).prefix(1).uppercased()
					+ swiftIdentifier(for: prop.name).dropFirst()
				let nestedStructInfo = generateStruct(
					name: String(nestedStructName),
					baseConformance: "JSEncodable",
					properties: nestedProps,
					indent: indent + "\t"
				)
				nestedStructInfos.append(nestedStructInfo)
			}
		}

		// Second pass: map all properties
		for prop in properties {
			let mapped: MappedType
			if prop.properties != nil {
				// This is a nested object type - use the generated struct name
				let nestedStructName =
					swiftIdentifier(for: prop.name).prefix(1).uppercased()
					+ swiftIdentifier(for: prop.name).dropFirst()
				let nestedInfo = nestedStructInfos.first {
					$0.name == nestedStructName
				}!
				mapped = MappedType(
					swiftType: String(nestedStructName)
						+ (prop.optional ? "?" : ""),
					isEncodable: nestedInfo.isEncodable,
					isOptional: prop.optional,
					isFunction: false,
					isNestedObject: true
				)
			} else {
				mapped = mapTypeScriptTypeToSwift(
					prop.type,
					isOptional: prop.optional,
					parameters: prop.parameters
				)
			}
			isEncodable = isEncodable && mapped.isEncodable
			mappedProps.append((prop: prop, mapped: mapped))
		}

		return (mappedProps, nestedStructInfos, isEncodable)
	}

	// Helper function to generate property declarations
	static func generateProperties(
		mappedProps: [(prop: PropDefinition, mapped: MappedType)],
		indent: String
	) -> String {
		var code = ""
		for (prop, mapped) in mappedProps {
			if let description = prop.description {
				code += "\(indent)/// \(description)\n"
			}
			code +=
				"\(indent)public let \(swiftIdentifier(for: prop.name)): \(mapped.swiftType)\n"
		}
		return code
	}

	// Helper function to generate initializer
	static func generateInitializer(
		mappedProps: [(prop: PropDefinition, mapped: MappedType)],
		indent: String
	) -> String {
		var code = ""
		code += "\n"
		code += "\(indent)public init(\n"
		for (index, (prop, mapped)) in mappedProps.enumerated() {
			let comma = index < mappedProps.count - 1 ? "," : ""
			let escaping =
				mapped.isFunction && !mapped.isOptional ? "@escaping " : ""
			code +=
				"\(indent)\t\(swiftIdentifier(for: prop.name)): \(escaping)\(mapped.swiftType)\(comma)\n"
		}
		code += "\(indent)) {\n"
		for (prop, _) in mappedProps {
			let propName = swiftIdentifier(for: prop.name)
			code += "\(indent)\tself.\(propName) = \(propName)\n"
		}
		code += "\(indent)}\n"
		return code
	}

	// Helper function to generate function callback registration code
	static func generateFunctionCallback(
		propName: String,
		mapped: MappedType,
		parameters: [PropDefinition]?,
		indent: String
	) -> String {
		var code = ""

		// Strip optional ? and parentheses when checking return type
		var baseType = mapped.swiftType
		if baseType.hasSuffix("?") {
			baseType = String(baseType.dropLast())
		}
		if baseType.hasPrefix("(") && baseType.hasSuffix(")") {
			baseType = String(baseType.dropFirst().dropLast())
		}

		// Extract return type from function signature
		let returnType: String
		if let arrowIndex = baseType.range(of: "->", options: .backwards) {
			returnType = baseType[arrowIndex.upperBound...].trimmingCharacters(
				in: .whitespaces
			)
		} else {
			returnType = "Void"
		}

		code += "context.registerSyncCallback { args in\n"

		// Parse parameters and call function using JSCall
		if let params = parameters, !params.isEmpty {
			// Build JSCall generic type with return type and parameter types
			let paramTypes = params.map { param in
				mapTypeScriptTypeToSwift(
					param.type,
					isOptional: param.optional,
					parameters: param.parameters
				).swiftType
			}.joined(separator: ", ")

			code += "\(indent)\tlet argsData = Data(args.utf8)\n"
			code +=
				"\(indent)\tlet jsCall = try JSONDecoder().decode(JSCall<\(returnType), \(paramTypes)>.self, from: argsData)\n"
			code += "\(indent)\treturn try jsCall.call(\(propName))\n"
		} else {
			// No parameters
			if returnType != "Void" && returnType != "()" {
				code += "\(indent)\tlet result = \(propName)()\n"
				code +=
					"\(indent)\treturn try BlockParty.dataToUTF8String(JSONEncoder().encode(result))\n"
			} else {
				code += "\(indent)\t\(propName)()\n"
				code += "\(indent)\treturn nil\n"
			}
		}

		code += "\(indent)}\n"
		return code
	}

	// Helper function to generate jsValue implementation
	static func generateJSValue(
		mappedProps: [(prop: PropDefinition, mapped: MappedType)],
		indent: String
	) -> String {
		var code = ""
		code += "\n"
		code +=
			"\(indent)public func jsValue(context: any JSEncodingContext) throws -> String {\n"

		// Check if any property is encodable
		let hasEncodableMembers = mappedProps.contains { $0.mapped.isEncodable }
		if hasEncodableMembers {
			code += "\(indent)\tlet encoder = JSONEncoder()\n"
		}

		code += "\(indent)\tvar jsExpr = \"{\"\n"
		for (index, (prop, mapped)) in mappedProps.enumerated() {
			let propName = swiftIdentifier(for: prop.name)
			let isFunction = mapped.isFunction
			let isNestedObject = mapped.isNestedObject

			if index > 0 {
				code += "\(indent)\tjsExpr += \",\"\n"
			}
			code += "\(indent)\tjsExpr += \"\\\"\(prop.name)\\\":\"\n"

			if isFunction {
				if mapped.isOptional {
					code += "\(indent)\tif let \(propName)Fn = \(propName) {\n"
					code += "\(indent)\t\tjsExpr += "
					code += generateFunctionCallback(
						propName: "\(propName)Fn",
						mapped: mapped,
						parameters: prop.parameters,
						indent: "\(indent)\t\t"
					)
					code += "\(indent)\t} else {\n"
					code += "\(indent)\t\tjsExpr += \"undefined\"\n"
					code += "\(indent)\t}\n"
				} else {
					code += "\(indent)\tjsExpr += "
					code += generateFunctionCallback(
						propName: propName,
						mapped: mapped,
						parameters: prop.parameters,
						indent: "\(indent)\t"
					)
				}
			} else if isNestedObject {
				// Nested object - call its jsValue method
				if mapped.isOptional {
					code += "\(indent)\tif let \(propName)Val = \(propName) {\n"
					code +=
						"\(indent)\t\tjsExpr += try \(propName)Val.jsValue(context: context)\n"
					code += "\(indent)\t} else {\n"
					code += "\(indent)\t\tjsExpr += \"null\"\n"
					code += "\(indent)\t}\n"
				} else {
					code +=
						"\(indent)\tjsExpr += try \(propName).jsValue(context: context)\n"
				}
			} else {
				// Regular Encodable property
				code +=
					"\(indent)\tjsExpr += try BlockParty.dataToUTF8String(encoder.encode(\(propName)))\n"
			}
		}
		code += "\(indent)\tjsExpr += \"}\"\n"
		code += "\(indent)\treturn jsExpr\n"
		code += "\(indent)}\n"
		return code
	}

	static func generateStruct(
		name: String,
		description: String? = nil,
		baseConformance: String,
		properties: [PropDefinition],
		indent: String
	) -> StructInfo {
		var code = ""
		var indent = indent

		// Add documentation if available
		if let description = description {
			code += "\(indent)/// \(description)\n"
		}

		// Process properties using shared helper
		let (mappedProps, nestedStructInfos, isEncodable) = processProperties(
			properties: properties,
			indent: indent
		)

		code +=
			"\(indent)public struct \(name): \(baseConformance)\(isEncodable ? ", Encodable" : "") {\n"

		indent += "\t"

		// Generate nested struct definitions
		for info in nestedStructInfos {
			code += info.openingCode
			code += "\(indent)}\n"
		}

		// Generate properties using helper
		code += generateProperties(mappedProps: mappedProps, indent: indent)

		// Generate initializer using helper
		code += generateInitializer(mappedProps: mappedProps, indent: indent)

		// If not encodable, generate custom jsValue implementation using helper
		if !isEncodable {
			code += generateJSValue(mappedProps: mappedProps, indent: indent)
		}

		return StructInfo(
			name: name,
			openingCode: code,
			isEncodable: isEncodable
		)
	}

	static func mapTypeScriptTypeToSwift<S: StringProtocol>(
		_ tsType: S,
		isOptional: Bool,
		parameters: [PropDefinition]?
	)
		-> MappedType
	{
		var isEncodable = true
		var isFunction = false
		var mappedType: String
		let cleanType = tsType.trimmingCharacters(in: .whitespaces)

		// Handle parts wrapped in parentheses first
		if cleanType.hasPrefix("(") && cleanType.hasSuffix(")") {
			let mapped = mapTypeScriptTypeToSwift(
				cleanType.dropFirst().dropLast(),
				isOptional: false,
				parameters: parameters
			)
			isEncodable = isEncodable && mapped.isEncodable
			isFunction = mapped.isFunction
			mappedType = "(\(mapped.swiftType))"
		} else {
			switch cleanType {
			case "string":
				mappedType = "String"
			case "number":
				mappedType = "Double"
			case "boolean":
				mappedType = "Bool"
			case "any":
				mappedType = "Any"
			case "void", "undefined", "null":
				mappedType = "Void"
			default:
				if cleanType.contains("|") && cleanType.contains("undefined") {
					// Handle union types with undefined (e.g., "string | undefined")
					let parts = cleanType.split(separator: "|").map {
						$0.trimmingCharacters(in: .whitespaces)
					}
					if let nonUndefinedType = parts.first(where: {
						$0 != "undefined"
					}) {
						return mapTypeScriptTypeToSwift(
							nonUndefinedType,
							isOptional: true,
							parameters: parameters
						)
					}
				}
				if let params = parameters {
					// Handle function types (e.g., "(x: number, y: number) => number")
					isEncodable = false
					isFunction = true

					let paramTypes = params.map { param in
						mapTypeScriptTypeToSwift(
							param.type,
							isOptional: param.optional,
							parameters: param.parameters
						).swiftType
					}

					// Get return type by parsing after =>
					let parts = cleanType.split(separator: "=>", maxSplits: 1)
					let returnType: String
					if parts.count == 2 {
						let returnTypeMapped = mapTypeScriptTypeToSwift(
							parts[1],
							isOptional: false,
							parameters: nil
						)
						returnType = returnTypeMapped.swiftType
					} else {
						returnType = "Void"
					}

					// Build Swift function type without parameter labels
					if paramTypes.isEmpty {
						mappedType = "() -> \(returnType)"
					} else {
						mappedType =
							"(\(paramTypes.joined(separator: ", "))) -> \(returnType)"
					}
				} else {
					mappedType = String(cleanType)
				}
			}
		}

		if isOptional {
			mappedType += "?"
		}

		return MappedType(
			swiftType: mappedType,
			isEncodable: isEncodable,
			isOptional: isOptional,
			isFunction: isFunction,
			isNestedObject: false
		)
	}

	static func swiftIdentifier(for name: String) -> String {
		// Replace hyphens with underscores and handle Swift keywords
		let sanitized = name.replacingOccurrences(of: "-", with: "_")

		// Check if it's a Swift keyword and escape it
		let swiftKeywords = [
			"associatedtype", "class", "deinit", "enum", "extension",
			"fileprivate",
			"func", "import", "init", "inout", "internal", "let", "open",
			"operator",
			"private", "precedencegroup", "protocol", "public", "rethrows",
			"static",
			"struct", "subscript", "typealias", "var", "break", "case", "catch",
			"continue", "default", "defer", "do", "else", "fallthrough", "for",
			"guard",
			"if", "in", "repeat", "return", "throw", "switch", "where", "while",
			"as",
			"false", "is", "nil", "self", "Self", "super", "throws", "true",
			"try",
		]

		if swiftKeywords.contains(sanitized) {
			return "`\(sanitized)`"
		}

		return sanitized
	}
}

enum BuildError: Error, CustomStringConvertible {
	case processFailure(exitCode: Int32)

	var description: String {
		switch self {
		case .processFailure(let exitCode):
			return "npx blockparty process failed with exit code \(exitCode)"
		}
	}
}
